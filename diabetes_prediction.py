# -*- coding: utf-8 -*-
"""diabetes prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jKn390GHd8k2DTYZaYRwZZblv9fitA3r
"""

#Libraries
  import numpy as np                   # used for mathematical operation for array manipulation
  import pandas as pd                   #Pandas allows us to analyze big data and make conclusions based on statistical theories.
  import matplotlib.pyplot as plt       # used for visual graphics
  import seaborn as sns                 #Seaborn is a library for making statistical graphics in Python

  #Data Preprocessing
  from sklearn.model_selection import train_test_split

  #Models ML
  from sklearn.svm import SVC

  #Metrics
  from sklearn.metrics import confusion_matrix,accuracy_score
  from sklearn.metrics import mean_squared_error,r2_score
  from sklearn import metrics

data= pd.read_csv('/content/diabetes.csv')
data.head()

data.shape

# There is not NaN or null values in columns
data.info()

data.describe()

list(data.describe().columns)

selecct_col_df=data.columns.to_list()
selecct_col_df

select_col_df = select_col_df.describe()
select_col_df

mean_value = select_col_df.iloc[1:2,:]
mean_value

mean_value = select_col_df.iloc[1:2,:].values[0]
mean_value

# Replacing the values equal to 0 by the median
for col in data[select_col]:
    data.loc[:,col].replace(0, data.loc[:,col].median(), inplace=True)
    # print(data.loc[:,col].median())
    # print(data.loc[:,col])

# print(col)
# data.loc[:,col].median()

data

data.describe()

corr = data[data.describe().columns].corr()
corr

plt.figure(figsize=(16,9))
corr = data.corr()
from matplotlib.colors import LinearSegmentedColormap
cmap = LinearSegmentedColormap.from_list('black_white', ['black', 'white'], N=256)
sns.heatmap(corr, annot=True, cmap=cmap)
plt.show()

# training and normalization of data
X = data.iloc[:,:8]
Y = data.iloc[:,8:]

X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.20, random_state=1)

# SScaler = StandardScaler()
# X_train = SScaler.fit_transform(X_train)
# X_test = SScaler.fit_transform(X_test)

from sklearn.svm import SVC
svc= SVC()
svc.fit(X_train,Y_train)

Y_pred = svc.predict(X_test)

accuracy= round(accuracy_score(Y_test,Y_pred), 5)*100 # Accuracy
print(accuracy)

Accuracy = accuracy_score(Y_test, Y_pred)
print('Accuracy: {} %'.format(Accuracy))
print('Mean squared error: ', round(mean_squared_error(Y_test,Y_pred),3))
cm=confusion_matrix(Y_test,Y_pred)
print(cm)
class_label = [0, 1]
df_cm = pd.DataFrame(cm, index=class_label,columns=class_label)
print(df_cm)
sns.heatmap(df_cm,annot=True,cmap='Set2',linewidths=2,fmt='d')
plt.title("Confusion Matrix",fontsize=15)
plt.xlabel("Predicted")
plt.ylabel("True")
plt.show()

"""For improving this model predition we have to tuned this model

"""

